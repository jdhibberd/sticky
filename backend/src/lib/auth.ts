/**
 * Helpers for managing the authentication of users.
 *
 * Encryption keys can be generated using:
 *
 *   import { subtle } from "crypto"
 *
 *    const key = await subtle.generateKey({
 *      name: 'HMAC',
 *      hash: "SHA-256",
 *    }, true, ['sign', 'verify']);
 *    subtle.exportKey("jwk", key)
 *      .then((v) => console.log(v.k))
 */

import { NextFunction, Request, Response } from "express";
import type { Session } from "./entity/sessions.js";
import { sessions } from "./entity/sessions.js";
import crypto from "crypto";

// make the user's session available on the express request object for
// convenience
declare module "express-serve-static-core" {
  interface Request {
    session: Session;
  }
}

// @frontend-export AUTH
export const OTP_LEN = 6;

// 30s, as recommended in RFC 6238:
// https://datatracker.ietf.org/doc/html/rfc6238
export const OTP_TTL = 30;

const UNAUTH_PATHS = ["/api/signin", "/api/signup"];

/**
 * Express handler for enforcing that the user has a valid session.
 *
 * If they have then the session is added to the Express request object for the
 * convenience of subsequent handlers. If they don't then an error is returned
 * and there is no further handling of the request.
 *
 * Sign in/up related API endpoints don't require authentication.
 */
export async function authRequest(
  req: Request,
  res: Response,
  next: NextFunction,
) {
  try {
    if (UNAUTH_PATHS.includes(req.originalUrl)) {
      next();
      return;
    }
    const session = await getSession(req);
    if (session === null) {
      res.status(401);
      res.end();
      return;
    }
    req.session = session;
    next();
  } catch (err) {
    next(err);
  }
}

/**
 * Get the current user session, or null if none exists.
 */
export async function getSession(req: Request): Promise<Session | null> {
  const sessionId = req.signedCookies.sessionId;
  // a value of undefined indicates that the user doesn't have a session cookie
  // and a value of false indicates that the signed session cookie has been
  // tampered with
  if (sessionId === undefined || sessionId === false) {
    return null;
  }
  return await sessions.select(sessionId);
}

/**
 * Create a new user session.
 */
export async function newSession(res: Response, userId: string): Promise<void> {
  const sessionId = await sessions.insert(userId);
  res.cookie("sessionId", sessionId, { signed: true });
}

/**
 * Generate a time-based OTP for a specific user.
 *
 * Implementation based on TOTP algorithm in RFC 6238:
 * https://datatracker.ietf.org/doc/html/rfc6238
 */
export function genOTP(secret: string, email: string): string {
  const now = Math.floor(Date.now() / 1000);
  const digest = crypto
    .createHmac("sha1", secret)
    .update(email)
    .update(now.toString(16))
    .digest("hex");
  const offset = parseInt(digest[digest.length - 1], 16);
  const slice = parseInt(digest.slice(offset * 2, offset * 2 + 8), 16);
  const otp = String(slice % 10 ** OTP_LEN);
  return otp.padStart(OTP_LEN, "0");
}

/**
 * Hash an OTP generated by `genOTP` for secure storage.
 */
export function hashOTP(secret: string, email: string, otp: string): string {
  return crypto
    .createHmac("sha1", secret)
    .update(email)
    .update(otp)
    .digest("hex");
}
