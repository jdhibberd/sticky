/**
 * Helpers for managing the authentication of users.
 *
 * Encryption keys can be generated using:
 *
 *   import { subtle } from "crypto"
 *
 *    const key = await subtle.generateKey({
 *      name: 'HMAC',
 *      hash: "SHA-256",
 *    }, true, ['sign', 'verify']);
 *    subtle.exportKey("jwk", key)
 *      .then((v) => console.log(v.k))
 */

import { NextFunction, Request, Response } from "express";
import type { Session } from "./entity/sessions.js";
import { sessions } from "./entity/sessions.js";
import crypto from "crypto";
import { User, users } from "./entity/users.js";
import { sendEmail } from "./mail.js";

// @frontend-export AUTH
export const OTP_LEN = 6;

export const OTP_TTL = 300; // 5 m
const SESSION_TTL = 1000 * 60 * 60 * 24 * 90; // 90 days in ms

const OTP_EMAIL_SENDER = `${process.env.APP_NAME} <noreply@hemingroth.com>`;
const OTP_EMAIL_SUBJECT = `${process.env.APP_NAME} OTP`;

/**
 * Express handler for enforcing that the user has a valid session.
 */
export async function authRequest(
  req: Request,
  res: Response,
  next: NextFunction,
) {
  try {
    if ((await getSession(req)) === null) {
      res.status(401);
      res.end();
      return;
    }
    next();
  } catch (err) {
    next(err);
  }
}

/**
 * Get the current session, or null if none exists.
 *
 * This function can be used to determine if the user is logged in.
 */
export async function getSession(req: Request): Promise<Session | null> {
  const sessionId = req.signedCookies.sessionId;
  // a value of undefined indicates that the user doesn't have a session cookie
  // and a value of false indicates that the signed session cookie has been
  // tampered with
  if (sessionId === undefined || sessionId === false) {
    return null;
  }
  return await sessions.select(sessionId);
}

/**
 * Return the current user (who owns the active session).
 *
 * Only call this function in a handler to which the `authRequest` handler has
 * already been applied (to verify that the user has an active session).
 */
export async function getCurrentUser(req: Request): Promise<User> {
  const session = await getSession(req);
  if (session === null) throw new Error("No session for current user.");
  const user = await users.select(session.userId);
  if (user === null) throw new Error("Current user not found.");
  return user;
}

/**
 * Create a new user session.
 */
export async function newSession(res: Response, userId: string): Promise<void> {
  const sessionId = await sessions.insert(userId, SESSION_TTL);
  res.cookie("sessionId", sessionId, {
    signed: true,
    maxAge: SESSION_TTL,
  });
}

/**
 * Generate a time-based OTP for a specific user.
 *
 * Implementation based on TOTP algorithm in RFC 6238.
 */
export function genOTP(secret: string, email: string): string {
  const now = Math.floor(Date.now() / 1000);
  const digest = crypto
    .createHmac("sha1", secret)
    .update(email)
    .update(now.toString(16))
    .digest("hex");
  const offset = parseInt(digest[digest.length - 1], 16);
  const slice = parseInt(digest.slice(offset * 2, offset * 2 + 8), 16);
  const otp = String(slice % 10 ** OTP_LEN);
  return otp.padStart(OTP_LEN, "0");
}

/**
 * Hash an OTP generated by `genOTP` for secure storage.
 */
export function hashOTP(secret: string, email: string, otp: string): string {
  return crypto
    .createHmac("sha1", secret)
    .update(email)
    .update(otp)
    .digest("hex");
}

/**
 * Send a user their OTP via email.
 */
export async function emailOTP(email: string, otp: string): Promise<void> {
  await sendEmail(
    OTP_EMAIL_SENDER,
    email,
    OTP_EMAIL_SUBJECT,
    `Your OTP is ${otp}. It's valid for ${OTP_TTL / 60} minutes.`,
  );
}
